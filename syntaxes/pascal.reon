#(
	; There's... a slight chance that I like regex way too much...

	name "Pascal"
	scopeName "source.pascal"
	fileTypes ["pas" "pp"]

	patterns [
		#(include #empty)
		#(
			match "\."
			name "keyword.operator.pascal"
		)
		#(include #unit)
		#(include #program)
		#(include #library)
		#(include #top-level)
		#(include #invalid)
	]

	repository #(
		empty #(
			patterns [
				#(include #line)
				#(include #space)
				#(include #line-comment)
				#(include #block-comment)
				#(include #preprocessor)
			]
		)

		const-exprs.record-or-array.record #(
			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*(?=\s*(?:(?:\(\*(?:\*+(?!\))|[^^*]+)*\*\)|\{[^^\{\}]*\})\s*)*:(?!=))"
					beginCaptures #(
						0 #(name "variable.property.pascal")
					)

					end ";|(?=\))"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(
							begin ":(?!=)"
							beginCaptures #(
								0 #(name "operator.pascal")
							)

							end "(?=[;)])"

							patterns [
								#(include #empty)
								#(include #const-exprs)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		const-exprs.record-or-array.array #(
			patterns [
				#(include #empty)
				#(include #comma)
				#(include #const-exprs)
				#(include #invalid)
			]
		)

		const-exprs.record-or-array #(
			begin "\("
			beginCaptures #(
				0 #(name "punctuation.definition.paren.begin.pascal")
			)

			end "\)"
			endCaptures #(
				0 #(name "punctuation.definition.paren.end.pascal")
			)

			patterns [
				#(include #empty)
				#(
					begin "(?=&?[a-zA-Z_]\w*\s*(?:(?:\(\*(?:\*+(?!\))|[^^*]+)*\*\)|\{[^^\{\}]*\})\s*)*:(?!=))"

					end "(?=\))"

					patterns [
						#(include #const-exprs.record-or-array.record)
					]
				)
				#(
					begin "(?=.)"

					end "(?=\))"

					patterns [
						#(include #const-exprs.record-or-array.array)
					]
				)
				#(include #invalid)
			]
		)

		const-exprs #(
			patterns [
				#(include #constants)
				#(include #builtins.intrinsic)
				#(include #builtins.const)
				#(include #const-exprs.record-or-array)
				;#(include #const-set)
				#(include #operators)
				#(include #basic-type.builtin)
				#(include #const-name)
			]
		)

		exprs.call-generic-fn #(
			begin "((?<=\b)(?<!&)specialize\s+)(&?[a-zA-Z_]\w*(?=<\S))"
			beginCaptures #(
				1 #(name "keyword.pascal")
				2 #(name "entity.name.function.pascal")
			)

			end "(?<=>)"

			patterns [
				#(include #generic-args)
				#(include #invalid)
			]
		)

		exprs #(
			patterns [
				#(include #builtins)
				#(include #constants)
				#(include #basic-type.builtin)
				#(include #operators)
				#(
					match "&?[a-zA-Z_]\w*(?=\s*\()"
					name "entity.name.function.pascal"
				)
				#(include #exprs.call-generic-fn)
				#(include #name)
				#(include #paren)
				#(include #subscript)
				#(include #illegal)
			]
		)

		top-level #(
			patterns [
				#(include #routine)
				#(include #types-section)
				#(include #vars-section)
				#(include #consts-section)
				#(include #property-section)
				#(include #uses-section)
				#(include #labels-section)
				#(include #resourcestrings-section)
				#(include #block)
				#(include #asm)
				#(include #keywords)
				#(include #semicolon)
				#(include #name)
			]
		)

		statements #(
			patterns [
				#(include #empty)
				#(include #semicolon)
				#(include #comma)
				#(include #colon)
				#(include #case-of)
				#(include #try-except-finally)
				#(include #block)
				#(include #asm)
				#(include #keywords)
				#(
					match "(&?[a-zA-Z_]\w*|\d+)\s*(:(?!=))" ; why not use label?
					captures #(
						1 #(name "variable.label.pascal")
						2 #(name "keyword.operator.pascal")
					)
				)
				#(include #exprs)
			]
		)

		space #(
			match "\s+"
			name "text.pascal"
		)

		line #(
			match "\n$"
			name "text.pascal"
		)

		line-comment #(
			match "//.*$"
			name "comment.pascal"
		)

		block-comment #(
			patterns [
				#(
					begin "\(\*(?!\$)"
					beginCaptures #(
						0 #(name "comment.pascal")
					)

					end "\*\)"
					endCaptures #(
						0 #(name "comment.pascal")
					)

					patterns [
						#(
							match "[^^*]+"
							name "comment.pascal"
						)
						#(
							match "\*+(?!\))"
							name "comment.pascal"
						)
					]
				)
				#(
					begin "\{(?!\$)"
					beginCaptures #(
						0 #(name "comment.pascal")
					)

					end "\}"
					endCaptures #(
						0 #(name "comment.pascal")
					)

					patterns [
						#(
							match "[^^}]+"
							name "comment.pascal"
						)
					]
				)
			]
		)

		preprocessor #(
			patterns [
				#(
					begin "(\(\*)(\$\w+)"
					beginCaptures #(
						1 #(name "comment.pascal")
						2 #(name "keyword.other.pascal")
					)

					end "\*\)"
					endCaptures #(
						0 #(name "comment.pascal")
					)

					patterns [
						#(
							match "[^^*]+"
							name "comment.pascal"
						)
						#(
							match "\*+(?!\))"
							name "comment.pascal"
						)
					]
				)
				#(
					begin "(\{)(\$\w+)([+\-]?)"
					beginCaptures #(
						1 #(name "comment.pascal")
						2 #(name "keyword.other.pascal")
						3 #(name "keyword.operator.pascal")
					)

					end "\}"
					endCaptures #(
						0 #(name "comment.pascal")
					)

					patterns [
						#(
							match "[^^}]+"
							name "comment.pascal"
						)
					]
				)
			]
		)

		comma #(
			match ","
			name "punctuation.separator.comma.pascal"
		)

		colon #(
			match ":(?!=)"
			name "punctuation.separator.colon.pascal"
		)

		semicolon #(
			match ";"
			name "punctuation.terminator.pascal"
		)

		dot #(
			match "\."
			name "operator.pascal"
		)

		invalid #(
			match "."
			name "invalid.illegal.pascal"
		)

		illegal #(
			match {[?\\`"\&]}
			name "invalid.illegal.pascal"
		)

		label #(
			match "(?<=^^\s*)(&?\w+)\s*(:(?!=))"
			captures #(
				1 #(name "variable.label.pascal")
				2 #(name "keyword.operator.pascal")
			)
		)

		builtins.intrinsic #(
			match {(?xi)(?<!(?<!\.)\.|\&)(?<=\b)(?:
				 break
				|continue
				|dec|default|dispose
				|exclude|exit
				|halt|high
				|inc|include
				|low
				|new
				|sizeof
			)(?!\.)(?=\b)}
			name "keyword.other.pascal"
		)

		builtins.const #(
			match {(?xi)(?<!(?<!\.)\.|\&)(?<=\b)(?:
				 abs|arctan
				|chr|cos
				|exp
				|ln
				|ord
				|pred
				|round
				|sin|sqrt?|succ
				|trunc
			)(?!\.)(?=\b)}
			name "entity.name.function.pascal"
		)

		builtins.standard #(
			match {(?xi)(?<!(?<!\.)\.|\&)(?<=\b)(?:
				 append|assign(?:ed|file)?
				|binStr|block(?:read|write)
				|close(?:file)?|concat|copy|copyArray
				|delete
				|eof|erase|error
				|floatToStr|flush|frac
				|insert|int|intToStr
				|hexStr
				|length
				|octStr
				|pos
				|read(?:ln|str)?|reset|rewrite
				|seek|set(?:length|jmp|string)|slice|str(?:to(?:int|float))?
				|truncate
				|varCast
				|write(?:ln|str)?
			)(?!\.)(?=\b)}
			name "entity.name.function.pascal"
		)

		builtins #(
			patterns [
				#(include #builtins.intrinsic)
				#(include #builtins.const)
				#(include #builtins.standard)
			]
		)

		constants.string #(
			begin "'"
			beginCaptures #(
				0 #(name "string.pascal")
			)

			end "'(?!')"
			endCaptures #(
				0 #(name "string.pascal")
			)

			patterns [
				#(
					match "''"
					name "constant.escape.pascal"
				)
				#(
					match {[^^']+}
					name "string.pascal"
				)
			]
		)

		constants #(
			patterns [
				#(
					match "(?:\$\h+|%[01]+|\&[0-7]+)(?=\b)"
					name "constant.numeric.pascal"
				)
				#(
					match "(?:(?<=[\s=\(\)\[\]])[+-])?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(?=\b)"
					name "constant.numeric.pascal"
				)
				#(
					match "#\d+(?=\b)"
					name "string.character.pascal"
				)
				#(include #constants.string)
				#(
					match "(?i)(?<!(?<!\.)\.|\&)(?:true|false|nil|self|result|maxint)(?=\b)"
					name "constant.language.pascal"
				)
			]
		)

		routine.trailing-attrs #(
			patterns [
				#(
					match {(?xi)
						(;)
						\s*
						(
							static|virtual|abstract|dynamic|reintroduce|override
							|alias
							|cdecl|cppdecl
							|default
							|export|external
							|far|forward
							|inline|interrupt|iocheck
							|local
							|message
							|near|noreturn|nostackframe
							|overload
							|pascal|public
							|register
							|safecall|saveregisters|softfloat|stdcall
							|varargs
							|winapi
						)(?=\s*;)
					}
					captures #(
						1 #(name "punctuation.terminator.pascal")
						2 #(name "keyword.modifier.pascal")
					)
				)
				#(
					begin "(?i)(;)\s*(alias)(?=\b)"
					beginCaptures #(
						1 #(name "punctuation.terminator.pascal")
						2 #(name "keyword.modifier.pascal")
					)

					end "(?=;)"

					patterns [
						#(include #empty)
						#(
							begin ":"
							beginCaptures #(
								0 #(name "operator.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #constants.string)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)(;)\s*(public)(?=\b)"
					beginCaptures #(
						1 #(name "punctuation.terminator.pascal")
						2 #(name "keyword.modifier.pascal")
					)

					end "(?=;)"

					patterns [
						#(include #empty)
						#(
							begin "(?i)name(?=\b)"
							beginCaptures #(
								0 #(name "keyword.modifier.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #constants.string)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)(;)\s*(message)(?=\b)"
					beginCaptures #(
						1 #(name "punctuation.terminator.pascal")
						2 #(name "keyword.modifier.pascal")
					)

					end "(?=;)"

					patterns [
						#(include #empty)
						#(include #constants)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)(;)\s*(external)(?=\b)"
					beginCaptures #(
						1 #(name "punctuation.terminator.pascal")
						2 #(name "keyword.modifier.pascal")
					)

					end "(?=;)"

					patterns [
						#(include #empty)
						#(include #constants.string)
						#(
							begin "(?i)name(?=\b)"
							beginCaptures #(
								0 #(name "keyword.modifier.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #constants.string)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)index(?=\b)"
							beginCaptures #(
								0 #(name "keyword.modifier.pascal")
							)

							end "\d+"
							endCaptures #(
								0 #(name "constant.numeric.pascal")
							)

							patterns [
								#(include #empty)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
			]
		)

		routine #(
			patterns [
				#(
					begin "(?i)(?<=\b)((?:(?:class|generic)\s+)?(?:function|procedure|(?:con|de)structor))\s+(?=&?[a-zA-Z_]\w*)"
					beginCaptures #(
						1 #(name "keyword.pascal")
					)

					end {(?xi);(?!\s*(?:
						static|virtual|abstract|dynamic|reintroduce|override
						|alias
						|cdecl|cppdecl
						|default
						|export|external
						|far|forward
						|inline|interrupt|iocheck
						|local
						|message
						|near|noreturn|nostackframe
						|overload
						|pascal|public
						|register
						|safecall|saveregisters|softfloat|stdcall
						|varargs
						|winapi
					)(?=\b))}
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					;-- basic generics for now
					patterns [
						#(include #empty)
						#(
							match "(&?[a-zA-Z_]\w*)(\.)"
							captures #(
								1 #(name "entity.name.type.pascal")
								2 #(name "operator.pascal")
							)
						)
						#(
							begin "&?[a-zA-Z_]\w*(?=<.+?>\s*[(:])"
							beginCaptures #(
								0 #(name "entity.name.function.pascal")
							)

							end "(?<=>)"

							patterns [
								#(include #generic-params)
								#(include #invalid)
							]
						)
						#(
							begin "&?[a-zA-Z_]\w*(?=<)"
							beginCaptures #(
								0 #(name "entity.name.type.pascal")
							)

							end "(?<=>)\."
							endCaptures #(
								0 #(name "operator.pascal")
							)
							
							patterns [
								#(include #generic-args)
								#(include #invalid)
							]
						)
						#(
							match "&?[a-zA-Z_]\w*(?=\s*[(:;])"
							name "entity.name.function.pascal"
						)
						#(
							begin "(?=[(:;])"

							end {(?xi)(?=;(?!\s*(?:
								static|virtual|abstract|dynamic|reintroduce|override
								|alias
								|cdecl|cppdecl
								|default
								|export|external
								|far|forward
								|inline|interrupt|iocheck
								|local
								|message
								|near|noreturn|nostackframe
								|overload
								|pascal|public
								|register
								|safecall|saveregisters|softfloat|stdcall
								|varargs
								|winapi
							)\b))}

							patterns [
								#(include #empty)
								#(include #routine-params)
								#(include #routine-return)
								#(include #routine.trailing-attrs)
							]
						)
						#(include #invalid)
					]
				)
				#(
					begin {(?xi)
						(?<=\b)((?:class\s+)?operator)
						\s+
						((?:[a-zA-Z_]\w*\s*\.\s*)*)
						(
							\+      |add
							|-      |subtract
							|\*     |multiply
							|/      |divide
							|\*\*   |power
							|><     |symmetricaldifference
							|=      |equal
							|<      |lessthan
							|<=     |lessthanorequal
							|>      |greaterthan
							|>=     |greaterthanorequal
							|<>     |notequal
							|:=     |assign
							|shr    |rightshift
							|shl    |leftshift
							|div    |intdivide
							|mod    |modulus
							|and    |bitwiseand|logicaland
							|or     |bitwiseor |logicalor
							|xor    |bitwisexor
							|not    |bitwisenot|logicalnot
							|explicit
							|in
							|enumerator
							|inc
							|dec
							|initialize|finalize|addref|copy
						)(?=\b)
					}
					beginCaptures #(
						1 #(name "keyword.pascal")
						2 #(
							patterns [
								#(
									match "([a-zA-Z_]\w*)(\.)"
									captures #(
										1 #(name "entity.name.type.pascal")
										2 #(name "operator.pascal")
									)
								)
							]
						)
						3 #(name "entity.name.function.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(include #routine-params)
						#(include #routine-return)
					]
				)
			]
		)

		routine-params #(
			begin "\("
			beginCaptures #(
				0 #(name "punctuation.definition.parameters.begin.pascal")
			)

			end "\)"
			endCaptures #(
				0 #(name "punctuation.definition.parameters.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(include #semicolon)
				#(
					match "(?i)(?<=\b)(?:const|var|constref|out)(?=\s+&?[a-zA-Z_])"
					name "keyword.pascal"
				)
				#(
					match "&?[a-zA-Z_]\w*"
					name "variable.parameter.pascal"
				)
				#(
					match "(?i)(:)\s*(array\s+of\s+const)(?=\s*[;)])"
					captures #(
						1 #(name "operator.pascal")
						2 #(name "keyword.pascal")
					)
				)
				#(include #type-anno)
				#(
					begin "="
					beginCaptures #(
						0 #(name "operator.pascal")
					)

					end "(?=\s*[;)])"

					patterns [
						#(include #empty)
						#(include #const-exprs)
						#(include #invalid)
					]
				)
			]
		)

		routine-return #(
			begin "((?:&?[a-zA-Z_]\w*\s*)?)(:)"
			beginCaptures #(
				1 #(name "variable.pascal")
				2 #(name "operator.pascal")
			)

			end "(?=;)"

			patterns [
				#(include #empty)
				#(include #basic-type)
				#(include #invalid)
			]
		)


		keywords #(
			match {(?xi)(?<!(?<!\.)\.|\&)(?<=\b)(?:
					absolute|asm|assembler|at
				|case|const
				|do|downto
				|else
				|for
				|goto
				|if|implementation|inherited|inline|interface
				|label
				|object|of|otherwise
				|packed|program
				|raise|record|reintroduce|repeat
				|set
				|then|to|type
				|until|uses
				|var
				|while|with
			)(?=\b)}
			name "keyword.pascal"
		)
		
		name #(
			match "&?[a-zA-Z_]\w*"
			name "source.pascal"
		)

		const-name #(
			match "&?[a-zA-Z_]\w*"
			name "constant.language.pascal"
		)

		param-name #(
			match "&?[a-zA-Z_]\w*"
			name "variable.parameter.pascal"
		)

		type-name #(
			match "&?[a-zA-Z_]\w*"
			name "entity.name.type.pascal"
		)

		paren #(
			begin "\("
			beginCaptures #(
				0 #(name "punctuation.definition.paren.begin.pascal")
			)

			end "\)"
			endCaptures #(
				0 #(name "punctuation.definition.paren.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(include #exprs)
				#(include #invalid)
			]
		)

		subscript #(
			begin "\["
			beginCaptures #(
				0 #(name "punctuation.definition.subscript.begin.pascal")
			)

			end "\]"
			endCaptures #(
				0 #(name "punctuation.definition.subscript.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #exprs)
			]
		)

		operators #(
			patterns [
				#(
					match {(?x)
						  [+\-/^^@]
						| \*\*?
						| [<>][<>=]?
						| [:+\-*/]?=
						| \.\.
					}
					name "keyword.operator.pascal"
				)
				#(include #dot)
				#(
					match {(?xi)(?<!(?<!\.)\.|\&)(?<=\b)(?:
						 div|mod
						|and(?:_then)?|or(?:_else)?|xor|not
						|shl|shr
						|in
						|is|as
					)(?=\b)}
					name "keyword.pascal"
				)
			]
		)

		type-anno #(
			begin ":(?!=)"
			beginCaptures #(
				0 #(name "operator.pascal")
			)

			end "(?<!:\s*)(?!<)"

			patterns [
				#(include #empty)
				#(include #type)
				#(include #generic-args)
				; ...
				#(include #invalid)
			]
		)


		;== BLOCKS ==;

		case-of #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)case(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #semicolon)
				#(include #comma)
				#(include #colon)
				#(include #case-of)
				#(include #try-except-finally)
				#(include #block)
				#(include #asm)
				#(include #keywords)
				#(include #exprs)
				#(include #invalid)
			]
		)

		try-except-finally #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)try(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #semicolon)
				#(include #comma)
				#(include #colon)
				#(include #case-of)
				#(include #try-except-finally)
				#(include #block)
				#(include #asm)
				#(
					match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:except|on|finally)(?=\b)"
					name "keyword.pascal"
				)
				#(include #keywords)
				#(include #label)
				#(include #exprs)
				#(include #invalid)
			]
		)

		block #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)begin(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #semicolon)
				#(include #comma)
				#(include #colon)
				#(include #case-of)
				#(include #try-except-finally)
				#(include #block)
				#(include #asm)
				#(include #keywords)
				#(include #label)
				#(include #exprs)
				#(include #invalid)
			]
		)


		;== ASM ==;
		
		asm.register.special #(
			match {(?xi)%?(?:
				  [er]? (?: [abcd]x | [sb]p )
				| edi
				| [abcd][hl]
				| r\d+
			)(?=\b)}
			name "constant.language.pascal"
		)

		asm.register #(
			patterns [
				#(include #asm.register.special)
				#(
					match "[a-zA-Z_]\w*"
					name "variable.name.pascal"
				)
			]
		)

		asm.constant.integer #(
			match "(?i)\d+B?"
			name "constant.numeric.pascal"
		)

		asm.constant.hex-integer #(
			match "\h+h"
			name "constant.numeric.pascal"
		)

		asm.constant #(
			patterns [
				#(include #asm.constant.hex-integer)
				#(include #asm.constant.integer)
			]
		)

		asm.macro #(
			match "@[a-zA-Z_]\w*"
			name "entity.name.function.pascal"
		)

		asm.operator #(
			match "[+\-]"
			name "keyword.operator.pascal"
		)

		asm.paren #(
			begin "\("
			beginCaptures #(
				0 #(name "punctuation.definition.paren.begin.pascal")
			)

			end "\)"
			endCaptures #(
				0 #(name "punctuation.definition.paren.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #asm.expr)
				#(include #invalid)
			]
		)

		asm.subscript #(
			begin "\["
			beginCaptures #(
				0 #(name "punctuation.definition.subscript.begin.pascal")
			)

			end "\]"
			endCaptures #(
				0 #(name "punctuation.definition.subscript.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #asm.expr)
				#(include #invalid)
			]
		)

		asm.expr #(
			patterns [
				#(include #asm.register)
				#(include #asm.constant)
				#(include #asm.macro)
				#(
					match "\.[a-zA-Z_]\w*"
					name "entity.name.function.pascal"
				)
				#(include #asm.operator)
				#(include #asm.paren)
				#(include #asm.subscript)
				#(include #colon)
				#(include #comma)
			]
		)

		asm.command #(
			begin {(?<=^^\s*)([a-zA-Z_]\w*)(?!\s*:)(?=\b)}
			beginCaptures #(
				1 #(name "keyword.pascal")
			)

			end "$"

			patterns [
				#(include #empty)
				#(include #asm.expr)
				#(include #invalid)
			]
		)

		asm.func-label #(
			match "(?<=^^\s*)(\.[a-zA-Z_]\w*)\s*(:(?!=))"
			captures #(
				1 #(name "entity.name.function.pascal")
				2 #(name "keyword.operator.pascal")
			)
		)

		asm #(
			begin "(?i)(?<=\b)asm(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #asm.command)
				#(include #label)
				#(include #asm.func-label)
				; ...
				#(include #invalid)
			]
		)

		
		;== TYPES ==;

		generic-args #(
			begin "(?<=\w)<(?!\s*[=<>(])"
			beginCaptures #(
				0 #(name "punctuation.definition.args.begin.pascal")
			)

			end ">"
			endCaptures #(
				0 #(name "punctuation.definition.args.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(include #type)
				#(include #invalid)
			]
		)

		basic-type.builtin #(
			match {(?xi)(?<=\b)(?:
				Integer|Shortint|SmallInt|Longint|Longword|Int64|Byte|Word|Cardinal|QWord
				|Boolean|ByteBool|WordBool|LongBool|QWordBool
				|Real|Single|Double|Extended|Comp|Currency
				|(?:P|Wide|P?Ansi|P?Unicode)?Char
				|(?:Short|Wide|Ansi|RawByte|UTF8|Unicode)String|String(?!\s*\[)
				|Pointer
				|Variant
			)(?=\b)}
			name "entity.name.type.pascal"
		)

		basic-type.user-defined #(
			match "(&?[a-zA-Z_]\w*(?<!(?i)(?<!(?<!\.)\.|\&)\b(?:array|set|record|object|class|interface|generic|specialize|procedure|function))(?:\.&?[a-zA-Z_]\w*)*)" ; add generics later lol
			captures #(
				1 #(
					patterns [
						#(
							match "&?[a-zA-Z_]\w*"
							name "entity.name.type.pascal"
						)
						#(
							match "\."
							name "operator.pascal"
						)
					]
				)
			)
		)

		basic-type #(
			begin "((?i)(?<=\b)(?<![\&\.])specialize\s+)?(\^^\s*)?(?=&?[a-zA-Z_])"
			beginCaptures #(
				1 #(name "keyword.pascal")
				2 #(name "keyword.operator.pascal")
			)

			end "(?<=[\w>])(?!<)"

			patterns [
				#(include #generic-args)
				#(include #basic-type.builtin)
				#(include #basic-type.user-defined)
			]
		)

		type.routine #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(function|procedure)"
			beginCaptures #(
				1 #(name "keyword.pascal")
			)

			end "((?:(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:is\s+nested|of\s+object))?)(?=\s*;)"
			endCaptures #(
				1 #(name "keyword.other.pascal")
			)
			
			patterns [
				#(include #empty)
				#(include #routine-params)
				#(
					begin "((?:&?[a-zA-Z_]\w*\s*)?)(:)"
					beginCaptures #(
						1 #(name "variable.pascal")
						2 #(name "operator.pascal")
					)

					end "(?=(?:(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:is\s+nested|of\s+object))?\s*;)"

					patterns [
						#(include #empty)
						#(include #basic-type)
						#(include #invalid)
					]
				)
			]
		)

		type.sized-string #(
			begin "(?i)(?<=\b)(string)\s*(\[)"
			beginCaptures #(
				1 #(name "entity.name.type.pascal")
				2 #(name "punctuation.definition.subscript.begin.pascal")
			)

			end "\]"
			endCaptures #(
				0 #(name "punctuation.definition.subscript.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #constants)
				#(include #operators)
				#(include #const-name)
				#(include #invalid)
			]
		)

		type.array #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)((?:(?:bit)?packed\s+)?array)(?=\b)"
			beginCaptures #(
				1 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?:(?<!(?<!\.)\.|\&)\b(?:array|of)|\])\s*)"

			patterns [
				#(include #empty)
				#(
					begin "\["
					beginCaptures #(
						0 #(name "punctuation.definition.subscript.begin.pascal")
					)

					end "\]"
					endCaptures #(
						0 #(name "punctuation.definition.subscript.end.pascal")
					)

					patterns [
						#(include #empty)
						#(include #constants)
						#(include #operators)
						#(include #basic-type.builtin)
						#(
							match {(?xi)
								(?<=(?:
									[+\-/@=(]
									| \*\*?
									| [<>][<>=]?
									| \.\.
								)\s*)
								&?[a-zA-Z_]\w*(?!\w*\s*\()
								|
								&?[a-zA-Z_]\w*(?!\w*\s*\()
								(?=\s*(?:
									[+\-/^^=)]
									| \*\*?
									| [<>][<>=]?
									| \.\.
								))
							}
							name "constant.language.pascal"
						)
						#(include #const-exprs)
						;#(include #basic-type)
						;#(include #const-name)
						#(include #comma)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)of(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?i)(?<!(?:(?<!(?<!\.)\.|\&)\b(?:array|of)|\])\s*)"

					patterns [
						#(include #empty)
						#(include #type-decl)
						#(include #type)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		type.set #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(set)(?=\b)"
			beginCaptures #(
				1 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!(?<!\.)\.|\&)\b(?:set|of)\s*)"

			patterns [
				#(include #empty)
				#(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)of(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?i)(?<!(?<!(?<!\.)\.|\&)\b(?:set|of)\s*)"

					patterns [
						#(include #empty)
						#(include #type-decl)
						#(include #type)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		type.file #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(file)(?=\b)"
			beginCaptures #(
				1 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!(?<!\.)\.|\&)\b(?:file|of)\s*)|(?=[;)>])"

			patterns [
				#(include #empty)
				#(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)of(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?i)(?<!(?<!(?<!\.)\.|\&)\b(?:file|of)\s*)|(?=[;)>])"

					patterns [
						#(include #empty)
						#(include #type-decl)
						#(
							match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)text(?=\b)"
							name "keyword.pascal"
						)
						#(include #type)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		generic-params #(
			begin "(?<=\w)<(?!\s*[=<>(])"
			beginCaptures #(
				0 #(name "punctuation.definition.parameters.begin.pascal")
			)

			end ">"
			endCaptures #(
				0 #(name "punctuation.definition.parameters.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #colon)
				#(include #semicolon)
				#(include #comma)
				#(
					match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:record|class|object|interface|constructor)(?=\b)"
					name "keyword.pascal"
				)
				#(include #type)
				#(include #invalid)
			]
		)

		type #(
			patterns [
				#(include #type.routine)
				#(include #type.sized-string)
				#(include #type.array)
				#(include #type.set)
				#(include #type.file)
				#(include #basic-type)
			]
		)


		;== OOP ==;
		
		oop.visibility.strict-private #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)strict(?=\b)"
			beginCaptures #(
				0 #(name "keyword.modifier.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)private(?=\b)"
			endCaptures #(
				0 #(name "keyword.modifier.pascal")
			)

			patterns [
				#(include #empty)
				#(include #invalid)
			]
		)

		oop.visibility.private #(
			match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)private(?=\b)"
			name "keyword.modifer.pascal"
		)

		oop.visibility.strict-private-protected #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)strict(?=\b)"
			beginCaptures #(
				0 #(name "keyword.modifier.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:private|protected)(?=\b)"
			endCaptures #(
				0 #(name "keyword.modifier.pascal")
			)

			patterns [
				#(include #empty)
				#(include #invalid)
			]
		)

		oop.visibility.protected #(
			match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)protected(?=\b)"
			name "keyword.modifer.pascal"
		)

		oop.visibility.public #(
			match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)public(?=\b)"
			name "keyword.modifer.pascal"
		)

		oop.visibility.published #(
			match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)published(?=\b)"
			name "keyword.modifer.pascal"
		)

		oop.visibility #(
			patterns [
				#(include #oop.visibility.strict-private-protected)
				#(include #oop.visibility.private)
				#(include #oop.visibility.protected)
				#(include #oop.visibility.public)
				#(include #oop.visibility.published)
			]
		)

		oop.property #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:class\s+)?property(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?=;(?!\s*(?:read|write|index|stored|implements|(?:no)?default)\b))"

			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "variable.pascal")
					)

					end "(?=;(?!\s*(?:read|write|index|stored|implements|(?:no)?default)\b))" ;@@ FIX

					patterns [
						#(
							begin "\["
							beginCaptures #(
								0 #(name "punctuation.definition.subscript.begin.pascal")
							)

							end "\]"
							endCaptures #(
								0 #(name "punctuation.definition.subscript.end.pascal")
							)

							patterns [
								#(include #empty)
								#(include #comma)
								#(include #semicolon)
								#(
									match "(?i)(?<=\b)(?:const|var|constref|out)(?=\s+&?[a-zA-Z_])"
									name "keyword.pascal"
								)
								#(
									match "&?[a-zA-Z_]\w*"
									name "variable.parameter.pascal"
								)
								#(
									match "(?i)(:)\s*(array\s+of\s+const)(?=\s*[;)\]])"
									captures #(
										1 #(name "operator.pascal")
										2 #(name "keyword.pascal")
									)
								)
								#(include #type-anno)
								#(
									begin "="
									beginCaptures #(
										0 #(name "operator.pascal")
									)

									end "(?=\s*[;)\]])"

									patterns [
										#(include #empty)
										#(include #constants)
										#(include #invalid)
									]
								)
							]
						)
						#(include #type-anno)
						#(
							begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:read|write)(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "(?i)(?=(?<!(?<!\.)\.|\&)(?<=\b)(?:read|write|index|stored|implements|(?:no)?default)\b|;)"

							patterns [
								#(include #empty)
								#(
									match "&?[a-zA-Z_]\w*"
									name "entity.name.function.pascal"
								)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)index(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "\d+"
							endCaptures #(
								0 #(name "constant.numeric.pascal")
							)

							patterns [
								#(include #empty)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)stored(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "(?i)(?=(?<!(?<!\.)\.|\&)(?<=\b)(?:read|write|index|stored|implements|(?:no)?default)\b|;)"

							patterns [
								#(include #empty)
								#(include #constants)
								#(include #name)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)implements(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "(?i)(?=(?<!(?<!\.)\.|\&)(?<=\b)(?:read|write|index|stored|implements|(?:no)?default)\b|;)"

							patterns [
								#(include #empty)
								#(include #comma)
								#(include #type)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)default(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "(?i)(?=(?<!(?<!\.)\.|\&)(?<=\b)(?:read|write|index|stored|implements|(?:no)?default)\b|;)"

							patterns [
								#(include #empty)
								#(include #constants)
								#(include #name)
								#(include #invalid)
							]
						)
						#(
							match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)nodefault(?=\b)"
							name "keyword.pascal"
						)
						#(
							match ";(?=\s*(?:read|write|index|stored|implements|(?:no)?default)\b)"
							name "punctuation.terminator.pascal"
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		oop.inheritance #(
			begin "(?i)(?<=\b(?:object|class(?:\s+(?:sealed|abstract))?|objcclass(?:\s+external)?|interface|(?:class|record|type)\s+helper)\s*)\("
			beginCaptures #(
				0 #(name "punctuation.definition.paren.begin.pascal")
			)

			end "\)"
			endCaptures #(
				0 #(name "punctuation.definition.paren.end.pascal")
			)

			patterns [
				#(include #empty)
				#(
					match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)specialize(?=\b)"
					name "keyword.pascal"
				)
				#(include #type)
				#(include #comma)
				#(include #invalid)
			]
		)

		oop.object-body #(
			patterns [
				#(include #empty)
				#(include #oop.inheritance)
				#(include #oop.visibility.private)
				#(include #oop.visibility.protected)
				#(include #oop.visibility.public)
				#(include #routine)
				#(
					match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)class\s+(?=var\b)"
					name "keyword.pascal"
				)
				#(include #vars-section)
				#(include #var-decl)
				#(include #semicolon)
				#(include #invalid)
			]
		)

		oop.class-body #(
			patterns [
				#(include #empty)
				#(include #oop.inheritance)
				#(include #oop.visibility)
				#(include #routine)
				#(
					match "(?i)(?<!(?<!\.)\.|\&)(?<=\b)class\s+(?=(?:var|property)\b)"
					name "keyword.pascal"
				)
				#(include #oop.property)
				#(include #types-section)
				#(include #vars-section)
				#(include #consts-section)
				#(include #var-decl)
				#(include #semicolon)
				#(include #invalid)
			]
		)


		;== DECLS ==;

		var-decl #(
			begin "&?[a-zA-Z_]\w*"
			beginCaptures #(
				0 #(name "variable.pascal")
			)

			end {(?xi);|(?=\b(?:
				(?:thread|class\s+)?var|const|type|resourcestring
				|(?:(?:generic|class)\s+)?(?:function|procedure|operator|constructor|destructor)
				|property
				|begin|end
				|strict|public(?!\s+name\s*'|\s*;)|private|protected
				|interface|implementation|initialization|finalization
				|uses|exports
				|label
				|asm|assembler
			)\b)}
			endCaptures #(
				0 #(name "punctuation.terminator.pascal")
			)

			patterns [
				#(include #empty)
				#(
					match "&?[a-zA-Z_]\w*"
					name "variable.pascal"
				)
				#(include #comma)
				#(include #type-anno)
				#(include #invalid)
			]
		)

		record-decl #(
			patterns [
				#(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:(?:bit)?packed\s+)?record(?!\s+helper\b)(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
					endCaptures #(
						0 #(name "keyword.pascal")
					)

					patterns [
						#(include #empty)
						#(include #~case)
						#(include #oop.visibility.strict-private)
						#(include #oop.visibility.private)
						#(include #oop.visibility.public)
						#(include #routine)
						#(include #oop.property)
						#(include #types-section)
						#(include #vars-section)
						#(include #consts-section)
						#(include #var-decl)
						#(include #semicolon)
						#(include #invalid)
					]
				)
			]

			repository #(
				~case #(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(case)\b"
					beginCaptures #(
						1 #(name "keyword.pascal")
					)

					end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?=end\b)|(?=\))"
					
					patterns [
						#(include #empty)
						#(
							match "(&?[a-zA-Z_]\w*)\s*(:)"
							captures #(
								1 #(name "variable.pascal")
								2 #(name "operator.pascal")
							)
						)
						#(
							begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(of)\b"
							beginCaptures #(
								1 #(name "keyword.pascal")
							)

							end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?=end\b)|(?=\))"

							patterns [
								#(include #empty)
								#(include #constants)
								#(
									match "(?<=\b)([a-zA-Z_]\w*)(\.)(&?[a-zA-Z_]\w*)(?!\.(?!\.))(?=\b)"
									captures #(
										1 #(name "entity.name.type.pascal")
										2 #(name "operator.pascal")
										3 #(name "constant.language.pascal")
									)
								)
								#(include #operators)
								#(include #const-name)
								#(include #semicolon)
								#(include #comma)
								#(include #colon)
								#(
									patterns [
										#(
											begin "\("
											beginCaptures #(
												0 #(name "punctuation.definition.paren.begin.pascal")
											)

											end "\)"
											endCaptures #(
												0 #(name "punctuation.definition.paren.end.pascal")
											)

											patterns [
												#(include #empty)
												#(include #~case)
												#(include #~var-decl)
												#(include #semicolon)
												#(include #invalid)
											]
										)
									]

									repository #(
										~var-decl #(
											begin "&?[a-zA-Z_]\w*"
											beginCaptures #(
												0 #(name "variable.pascal")
											)

											end "(?=[;)>])"

											patterns [
												#(include #empty)
												#(
													match "&?[a-zA-Z_]\w*"
													name "variable.pascal"
												)
												#(include #comma)
												#(
													begin ":"
													beginCaptures #(
														0 #(name "operator.pascal")
													)

													end "(?<!:\s*)"

													patterns [
														#(include #empty)
														#(include #~case)
														#(include #type-decl)
														#(include #type)
													]
												)
												#(include #invalid)
											]
										)
									)
								)
								#(include #invalid)
							]
						)
						#(include #type-decl)
						#(include #type)
						#(include #invalid)
					]
				)
			)
		)

		enum-decl #(
			begin "\("
			beginCaptures #(
				0 #(name "punctuation.definition.paren.begin.pascal")
			)

			end "\)"
			endCaptures #(
				0 #(name "punctuation.definition.paren.end.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "constant.language.pascal")
					)

					end "(?=[,)])"

					patterns [
						#(include #empty)
						#(
							begin ":?="
							beginCaptures #(
								0 #(name "keyword.operator.pascal")
							)

							end "(?=[,)])"

							patterns [
								#(include #empty)
								#(include #constants)
								#(include #const-name)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		object-decl #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:packed\s+)?object(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #oop.object-body)
				#(include #invalid)
			]
		)

		class-decl #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:(?:packed\s+)?class(?:\s+(?:abstract|sealed))?(?!\s+(?:of|helper)\b|\s*;)|objcclass(?:\s+external)?)(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #oop.class-body)
				#(include #invalid)
			]
		)

		class-forward-decl #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:objc)?class(?!\s+helper\b)(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?=;)"

			patterns [
				#(include #empty)
				#(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)of(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?=;)"

					patterns [
						#(include #empty)
						#(include #type)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		interface-decl #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)interface(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(
					begin "(?i)(?<=(?:\binterface|\])\s*)\("
					beginCaptures #(
						0 #(name "punctuation.definition.paren.begin.pascal")
					)

					end "\)"
					endCaptures #(
						0 #(name "punctuation.definition.paren.end.pascal")
					)

					patterns [
						#(include #empty)
						#(
							match "(?i)(?<!(?<!\.)\.|\&)specialize(?=\b)"
							name "keyword.pascal"
						)
						#(include #type)
						#(include #comma)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)(?<=(?:\binterface|\)|^^)\s*)\["
					beginCaptures #(
						0 #(name "punctuation.definition.uuid.begin.pascal")
					)

					end "\]"
					endCaptures #(
						0 #(name "punctuation.definition.uuid.end.pascal")
					)

					patterns [
						#(include #empty)
						#(include #constants)
						#(include #invalid)
					]
				)
				#(
					begin "(?!\s*(?:\(|$))"

					end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?=end\b)"

					patterns [
						#(include #empty)
						#(include #routine)
						#(include #oop.property)
						#(include #semicolon)
						#(include #invalid)
					]
				)
			]
		)

		enum-range-decl #(
			begin "(?=-?(?:[$%\&#\d]|[a-zA-Z_]\w*\s*\.\.))"
			
			end "(?=;)"

			patterns [
				#(include #constants)
				#(include #const-name)
				#(include #operators)
				#(include #invalid)
			]
		)

		helper-decl #(
			begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?:class|record|type)\s+helper(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)end(?=\b)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(include #oop.inheritance)
				#(
					begin "(?i)(?<!(?<!\.)\.|\&)(?<=\b)for(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?=end\b)"
					
					patterns [
						#(include #empty)
						#(include #type)
						#(
							begin "(?i)(?<!(?<!(?<!\.)\.|\&)\bfor\s+)"
							
							end "(?i)(?<!(?<!\.)\.|\&)(?<=\b)(?=end\b)"

							patterns [
								#(include #empty)
								#(include #routine)
								#(include #oop.visibility)
								#(include #oop.property)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		type-decl #(
			patterns [
				#(include #record-decl)
				#(include #enum-decl)
				#(include #object-decl)
				#(include #class-decl)
				#(include #class-forward-decl)
				#(include #interface-decl)
				#(include #enum-range-decl)
				#(include #helper-decl)
			]
		)

		
		;== SECTIONS ==;
		
		types-section #(
			begin "(?i)(?<=\b)(type)(?=\b)"
			beginCaptures #(
				1 #(name "keyword.pascal")
			)
			
			end {(?xi)(?=\b(?:
				(?:thread|class\s+)?var|const|type|resourcestring
				|(?:(?:generic|class)\s+)?(?:function|procedure|operator|constructor|destructor)
				|property
				|case|begin|end
				|strict|public|private|protected
				|interface|implementation|initialization|finalization
				|uses|exports
				|label
				|asm|assembler
			)\b)}

			patterns [
				#(include #empty)
				#(
					begin "(?i)(?<!\.)(?:(?=\s*&)|(?<=\b))((?:generic\s+)?)(&?[a-zA-Z_]\w*)"
					beginCaptures #(
						1 #(name "keyword.pascal")
						2 #(name "entity.name.type.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(include #generic-params)
						#(
							begin "="
							beginCaptures #(
								0 #(name "operator.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(
									match "(?i)(?<=\b)(?:type(?!\s+helper\b)|specialize)(?=\b)"
									name "keyword.pascal"
								)
								#(include #type-decl)
								#(include #type)
								; ...
							]
						)
					]
				)
				#(include #invalid)
			]
		)

		vars-section #(
			begin "(?i)(?<=\b)(?:thread)?var(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)
			
			end {(?xi)(?=\b(?:
				(?:thread|class\s+)?var|const|type|resourcestring
				|(?:(?:generic|class)\s+)?(?:function|procedure|operator|constructor|destructor)
				|property
				|begin|end
				|strict|public(?!\s+name\s*'|\s*;)|private|protected
				|interface|implementation|initialization|finalization
				|uses|exports
				|label
				|asm|assembler
			)\b)}

			patterns [
				#(include #empty)
				#(
					begin "(?i)external(?=\b)"
					beginCaptures #(
						0 #(name "keyword.modifier.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(include #constants.string)
						#(
							begin "(?i)name(?=\b)"
							beginCaptures #(
								0 #(name "keyword.modifier.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #constants.string)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)(?:public|export)(?=\b)"
					beginCaptures #(
						0 #(name "keyword.modifier.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(
							begin "(?i)name(?=\b)"
							beginCaptures #(
								0 #(name "keyword.modifier.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #constants.string)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(
					begin "(?i)cvar(?=\b)"
					beginCaptures #(
						0 #(name "keyword.modifier.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(include #invalid)
					]
				)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "variable.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(
							begin "(?i)absolute(?=\b)"
							beginCaptures #(
								0 #(name "keyword.modifier.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(
									match "\d+"
									name "constant.numeric.pascal"
								)
								#(include #name)
								#(include #invalid)
							]
						)
						#(
							match "&?[a-zA-Z_]\w*"
							name "variable.pascal"
						)
						#(include #comma)
						#(include #type-anno)
						#(
							begin "="
							beginCaptures #(
								0 #(name "operator.pascal")
							)
						
							end "(?=\s*[;)])"
						
							patterns [
								#(include #empty)
								#(include #constants)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		consts-section #(
			begin "(?i)(?<=\b)const(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)
			
			end {(?xi)(?=\b(?:
				(?:thread|class\s+)?var|const|type|resourcestring
				|(?:(?:generic|class)\s+)?(?:function|procedure|operator|constructor|destructor)
				|property
				|begin|end
				|strict|public(?!\s+name\s*'|\s*;)|private|protected
				|interface|implementation|initialization|finalization
				|uses|exports
				|label
				|asm|assembler
			)\b)}

			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "constant.language.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(include #type-anno)
						#(
							begin "="
							beginCaptures #(
								0 #(name "operator.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #const-exprs)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		resourcestrings-section #(
			begin "(?i)(?<=\b)resourcestring(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end {(?xi)(?=\b(?:
				(?:thread)?var|const|type|resourcestring
				|(?:(?:generic|class)\s+)?(?:function|procedure|operator|constructor|destructor)
				|property
				|begin
				|strict|public(?!\s+name\s*'|\s*;)|private|protected
				|interface|implementation|initialization|finalization
				|uses|exports
				|label
				|asm|assembler
			)\b)}

			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "constant.language.pascal")
					)

					end ";"
					endCaptures #(
						0 #(name "punctuation.terminator.pascal")
					)

					patterns [
						#(include #empty)
						#(
							begin "="
							beginCaptures #(
								0 #(name "operator.pascal")
							)

							end "(?=;)"

							patterns [
								#(include #empty)
								#(include #const-exprs)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		property-section #(
			begin "(?i)(?<=\b)property(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?=;)"

			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "variable.pascal")
					)

					end "(?=;)"

					patterns [
						#(
							begin "\["
							beginCaptures #(
								0 #(name "punctuation.definition.subscript.begin.pascal")
							)

							end "\]"
							endCaptures #(
								0 #(name "punctuation.definition.subscript.end.pascal")
							)

							patterns [
								#(include #empty)
								#(include #comma)
								#(include #semicolon)
								#(
									match "(?i)(?:const|var|constref|out)(?=\s+&?[a-zA-Z_])"
									name "keyword.pascal"
								)
								#(
									match "&?[a-zA-Z_]\w*"
									name "variable.parameter.pascal"
								)
								#(
									match "(?i)(:)\s*(array\s+of\s+const)(?=\s*[;)\]])"
									captures #(
										1 #(name "operator.pascal")
										2 #(name "keyword.pascal")
									)
								)
								#(include #type-anno)
								#(
									begin "="
									beginCaptures #(
										0 #(name "operator.pascal")
									)

									end "(?=\s*[;)\]])"

									patterns [
										#(include #empty)
										#(include #constants)
										#(include #invalid)
									]
								)
							]
						)
						#(include #type-anno)
						#(
							begin "(?i)(?:read|write)(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "(?i)(?=(?:read|write|index|(?:no)?default)\b|;)"

							patterns [
								#(include #empty)
								#(
									match "[a-zA-Z_]\w*"
									name "entity.name.function.pascal"
								)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)index(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "\d+"
							endCaptures #(
								0 #(name "constant.numeric.pascal")
							)

							patterns [
								#(include #empty)
								#(include #invalid)
							]
						)
						#(
							begin "(?i)default(?=\b)"
							beginCaptures #(
								0 #(name "keyword.pascal")
							)

							end "(?i)(?=(?:read|write|index|(?:no)?default)\b|;)"

							patterns [
								#(include #empty)
								#(include #constants)
								#(include #name)
								#(include #invalid)
							]
						)
						#(
							match "(?i)nodefault(?=\b)"
							name "keyword.pascal"
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		; TODO: fix {$ifdef} ... {$endif} blocks.
		uses-section #(
			begin "(?i)(?<=\b)uses(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end ";"
			endCaptures #(
				0 #(name "punctuation.terminator.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(
					begin "(?i)in(?=\b)"
					beginCaptures #(
						0 #(name "keyword.pascal")
					)

					end "(?<=')"

					patterns [
						#(include #empty)
						#(include #constants.string)
						#(include #invalid)
					]
				)
				#(include #name)
				#(include #dot)
				#(include #invalid)
			]
		)

		exports-section #(
			begin "(?i)(?<=\b)exports(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end ";"
			endCaptures #(
				0 #(name "punctuation.terminator.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(
					match "(?i)name(?=\b)"
					name "keyword.pascal"
				)
				#(include #name)
				#(include #invalid)
			]
		)

		labels-section #(
			begin "(?i)(?<=\b)label(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end ";"
			endCaptures #(
				0 #(name "punctuation.terminator.pascal")
			)

			patterns [
				#(include #empty)
				#(include #comma)
				#(
					match "&?[a-zA-Z_]\w*"
					name "variable.label.pascal"
				)
				#(include #invalid)
			]
		)

		interface-section #(
			begin "(?i)(?<=\b)interface(?!\s*\()(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\b)(?=implementation\b)"

			patterns [
				#(include #empty)
				#(include #top-level)
				#(include #invalid)
			]
		)

		implementation-section #(
			begin "(?i)(?<=\b)implementation(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\b)(?=(?:initialization|finalization|end)\b)"

			patterns [
				#(include #empty)
				#(include #exports-section)
				#(include #top-level)
				#(include #invalid)
			]
		)

		initialization-section #(
			begin "(?i)(?<=\b)initialization(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\b)(?=(?:finalization|end)\b)"

			patterns [
				#(include #statements)
				#(include #invalid)
			]
		)

		finalization-section #(
			begin "(?i)(?<=\b)finalization(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\b)(?=end\b)"

			patterns [
				#(include #statements)
				#(include #invalid)
			]
		)


		;== MAIN ==;

		unit #(
			begin "(?i)(?<=\b)unit(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\b)end(?=\s*(?:(?:\(\*(?:\*+(?!\))|[^^*]+)*\*\)|\{[^^\{\}]*\})\s*)*)"
			endCaptures #(
				0 #(name "keyword.pascal")
			)

			patterns [
				#(include #empty)
				#(
					match "(&?[a-zA-Z_]\w*)(\.)"
					captures #(
						1 #(name "entity.name.type.pascal")
						2 #(name "keyword.operator.pascal")
					)
				)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "entity.name.type.pascal")
					)

					end "(?i)(?=end\s*(?:(?:\(\*(?:\*+(?!\))|[^^*]+)*\*\)|\{[^^\{\}]*\})\s*)*\.)"

					patterns [
						#(include #empty)
						#(
							begin ";"
							beginCaptures #(
								0 #(name "punctuation.terminator.pascal")
							)

							end "(?i)(?=end\s*(?:(?:\(\*(?:\*+(?!\))|[^^*]+)*\*\)|\{[^^\{\}]*\})\s*)*\.)"

							patterns [
								#(include #empty)
								#(include #interface-section)
								#(include #implementation-section)
								#(include #initialization-section)
								#(include #finalization-section)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		program #(
			begin "(?i)(?<=\b)program(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\bend\s*)\."
			endCaptures #(
				0 #(name "keyword.operator.pascal")
			)

			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "entity.name.type.pascal")
					)

					end "(?i)(?<=\bend\s*)(?=\.)"

					patterns [
						#(include #empty)
						#(
							begin "\("
							beginCaptures #(
								0 #(name "punctuation.definition.paren.begin.pascal")
							)

							end "\)"
							endCaptures #(
								0 #(name "punctuation.definition.paren.end.pascal")
							)

							patterns [
								#(include #empty)
								#(include #comma)
								#(include #param-name)
								#(include #invalid)
							]
						)
						#(
							begin ";"
							beginCaptures #(
								0 #(name "punctuation.terminator.pascal")
							)

							end "(?i)(?<=\bend\s*)(?=\.)"

							patterns [
								#(include #empty)
								#(include #top-level)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)

		library #(
			begin "(?i)(?<=\b)library(?=\b)"
			beginCaptures #(
				0 #(name "keyword.pascal")
			)

			end "(?i)(?<=\bend\s*)\."
			endCaptures #(
				0 #(name "keyword.operator.pascal")
			)

			patterns [
				#(include #empty)
				#(
					begin "&?[a-zA-Z_]\w*"
					beginCaptures #(
						0 #(name "entity.name.type.pascal")
					)

					end "(?i)(?<=\bend\s*)(?=\.)"

					patterns [
						#(include #empty)
						#(
							begin "\("
							beginCaptures #(
								0 #(name "punctuation.definition.paren.begin.pascal")
							)

							end "\)"
							endCaptures #(
								0 #(name "punctuation.definition.paren.end.pascal")
							)

							patterns [
								#(include #empty)
								#(include #comma)
								#(include #param-name)
								#(include #invalid)
							]
						)
						#(
							begin ";"
							beginCaptures #(
								0 #(name "punctuation.terminator.pascal")
							)

							end "(?i)(?<=\bend\s*)(?=\.)"

							patterns [
								#(include #empty)
								#(include #exports-section)
								#(include #top-level)
								#(include #invalid)
							]
						)
						#(include #invalid)
					]
				)
				#(include #invalid)
			]
		)
	)
)